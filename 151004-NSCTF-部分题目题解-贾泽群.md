#NSCTF 部分题目题解

2015-10-4 贾泽群

---
前段时间做了NSCTF的比赛，做出了其中的几道题目，下面对几道题目的解题过程进行简单的分析。

##1. Crypto50 神奇的字符串

###题目：
![crypto50](http://7xn2d3.com1.z0.glb.clouddn.com/imgcrypto50.png)

###解题过程：
观察题目中的字符串，应该是进行了加密之后得到的字符串。利用网上的解密工具进行Base64解密，AES解密等解密工具以后发现，是使用了AES进行了加密。解密后的密文为：

> flag{DISJV_Hej_UdShofjyed}

根据NSCTF的flag规则，flag应该是以**“NSCTF_”**开头的，而解密后得到的结果的前几位是**“DISJV”**,
猜测是否使用了最常见的移位方法进行了加密。
于是进行一下验证，首先将DISJV几个字母与NSCTF对应

> 原：ABCDEFGHIJKLMNOPQRSTUVWXYZ

> 移：  S  V       D    IJ

进行补全后如下：

> 原：ABCDEFGHIJKLMNOPQRSTUVWXYZ

> 移：QRSTUVWXYZABCDEFGHIJKLMNOP

发现能够完全对应。于是将flag中剩下的字母按照大小写进行对应，最终得到最后的flag：
> NSCTF_Rot_EnCryption


##2. Web200 Decode

###题目要求：
![web200Decode](http://7xn2d3.com1.z0.glb.clouddn.com/imgweb200Decode.png)
本题目的要求比较简单，是针对一个已经给出源代码的PHP加密函数，解密加密后的密文。
###解题过程：
根据题目要求，只需要弄懂加密代码中的使用的几种加密方法即可。

要解密文，只需要按照与加密顺序相反的顺序进行解密即可。

首先分析源代码，我们可以看到最后进行的操作是`str_rot13`这个函数。我们查看这个函数的介绍：
```
str_rot13() 函数对字符串执行 ROT13 编码。

ROT-13 编码是一种每一个字母被另一个字母代替的方法。这个代替字母是由原来的字母向前移动 13 个字母而得到的。数字和非字母字符保持不变。

提示：编码和解码都是由相同的函数完成的。如果您把一个已编码的字符串作为参数，那么将返回原始字符串。
```
从这里我们可以清楚地知道，rot13编码的加密和解密函数其实是同一个函数，只要对密文再进行一遍rot13编码即可解密。因此我们的第一步就是再次调用`str_rot13`函数，处理密文。

然后，我们可以看到倒数第二步进行的操作是`strrev`函数，这个函数是对字符串进行反转，也就是倒序输出。很明显，要还原密文，只需要再次调用`strrev`函数对上一步的密文进行处理即可。

接着，我们发现加密算法还对密文进行了base64加密，只需要调用`base64_decode`函数就可以解密。

接着，我们再来分析上面的for循环中的内容。从for循环上面的语句来看，我们知道$_o中的字符串应该是原文的倒序。
然后我们来看for循环对$_o这个函数进行了怎样的操作:

第一步是看循环的次数，我们可以清楚的看出是循环了`strlen($_o)`次，也就是与$_o的长度等长。
然后`$_c = substr($_o, $_O, 1)`这个是从字符串的第$_O个位置截取1个字符出来，赋值给$_c。
接着`$__ = ord($_c) + 1`和`$_c = chr($__)`两句的意思是，先将刚才的字符转换为ascii码，加1以后再转回字符。
最后再把这个新的字符挨个连接起来生成$_这个变量。

综合来看，其实就是将原文中所有的字符都加1。那我们要解密的话也可以使用类似的方法，对密文中所有的字符循环减1。这样就得到了$_o中的内容。

然后我们说过,$_o和$str中的数据是相互逆序的关系，我们只需要再对$_o进行一遍逆序，就可以得到原文了！

以下是解密函数的代码：
```
<?php
$sec = "a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws";

$sec = str_rot13($sec);
$sec = strrev($sec);
$sec = base64_decode($sec);

for($i = strlen($sec) - 1; $i >= 0; $i--) 
{
	$c = substr($sec, $i, 1);
	$__ = ord($c) - 1;
	$c = chr($__);
	$_ = $c.$_;
}

echo strrev($_);

?>
```
在php服务器上执行以上代码，就可以得到原文。


##3.MISC250 WireShark
###题目要求：
![wireshark](http://7xn2d3.com1.z0.glb.clouddn.com/imgwireshark.png)

###解题思路：
首先根据题目的描述，使用wireshark打开下载到的文件。题目中描述，这里面有室友下载的小东东。
既然是下载的内容，首先考虑的就是HTTP协议和FTP协议，然后在记录中查找可以找到下面的记录。

![wireshark2](http://7xn2d3.com1.z0.glb.clouddn.com/imgwireshark2.png)

划红线的部分可以看到，用户下载了一个key.rar的文件。然后我们找到下面一个从服务器发来的包，就可以找到key.rar的文件的内容。
将数据dump到文件中发现，是一个加密的rar文件。

继续在抓到的包中寻找发现，在rar之前的http包中发现，用户还浏览过一个html文件，使用相同的方式将html文件保存下来，打开后发现文件内容大概是这样：
> 密码是nsfocus+5位数字

接下来就只能使用暴力破解了，这里我使用的是ARCHPR 4.54这个软件，但是由于密码规则比较特殊，前几位是固定的字母，而最后五位是数字，使用其默认的规则有些困难。
因此，我手动编写了一个小程序，将所有nsfocus+5位数字的可能性全部输出到了一个文件里，将这个文件作为字典文件，使用字典类型的破解，最终获取了密码，然后得到了该文件中的flag。


##4.MISC400 小绿的女神
###题目要求：
![card](http://7xn2d3.com1.z0.glb.clouddn.com/imgcard.png)

这个题目有点特殊，是上传一个card文件，模拟刷卡，然后可以在网页上模拟消费和查询余额两个操作。

###解题过程：
拿到这个题目，首先上传card文件上去，然后点击查询余额，发现显示了余额，并且页面中显示了card文件的16进制内容，然后再次进行刷卡操作，提示消费了**元，并且更新了显示的card的内容。
注意到操作前后显示的内容是不同的， 因此可以猜测，变化的部分就是存储卡的余额的相关部分。
使用文件对比工具，比较一下变化的内容：

![card2](http://7xn2d3.com1.z0.glb.clouddn.com/imgcard2.png)

可以看到0x40和0xC0那两行有变化。再次仔细对比可以发现，0xC0~0xC3部分表示的是当前余额：

余额为 96.41， 0xC0~0xC3部分内容为 A9 25 00 00。应该是按照内存中数据的存储方式，高位数据在内存地址大的位置。也就是说其值应该为00 00 25 A9,即9641。

而0xC4~0xC7部分是0xFFFFFFFF减去余额。
直接修改该部分和其后相同的部分发现，系统提示不通过，也就是卡片内容修改之后不能通过系统的验证了。继续观察发现：
继续观察发现，另一部分发生变化的0x40~0x43与0xC0~0xC3部分的和是不变的！

将两部分对应好之后修改发现，卡片的余额确实发生了变化，但是不能达到预期的数字。因为即使把0x40~0x43部分改成0，也不能余额达到208那么大的数字。也就是说这两部分的总和根本就不到208，只修改这两部分肯定不能达到要求。

这是我们继续观察发现，0x80那一行的数据也与其他为00的数据不同，肯定与其他数据有关联。经过计算发现，0x80那一行的数据就是0x40和0xC0的和，0x80的数据就是卡片的总和！
这样就很简单了，只需要将0x80那一行的数据改成足够大，然后把0xC0部分修改为 40 51 00 00 (其他部分相应修改)就可以查询到208的余额了！然后就能看到弹出的flag了。